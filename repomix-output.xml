This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
README.md
server/db.js
server/index.js
server/models/Message.js
server/routes.js
web/dashboard.css
web/dashboard.html
web/dashboard.js
web/index.html
web/login.css
web/login.html
web/login.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Environment
.env
.env.*

# Build
dist/
build/

# OS files
.DS_Store

# Editor
.vscode/
.idea/
</file>

<file path="package.json">
{
  "name": "sms-container-server",
  "version": "1.0.0",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.4",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    
    "dotenv": "^16.0.3"
  },
  "devDependencies": {
    "nodemon": "^3.1.0"
  },
  "engines": {
    "node": ">=16"
  }
}
</file>

<file path="README.md">
# SMS Container Server - Improved Version

## Overview
A professional SMS Container Server with email/password authentication, improved validation, and clean web interface.

**NO DOCKER NEEDED** - Simple setup with Node.js + MongoDB

---

## üéØ Key Features

- ‚úÖ Email & Password Authentication (stored in .env)
- ‚úÖ Clean two-page web interface (login + dashboard)
- ‚úÖ Improved API validation and error handling
- ‚úÖ Professional, minimal design
- ‚úÖ Fully responsive
- ‚úÖ Single admin user (no database auth needed)

---

## üìÅ Project Structure

```
sms-container-server/
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ index.js           # Main server
‚îÇ   ‚îú‚îÄ‚îÄ routes.js          # API routes
‚îÇ   ‚îú‚îÄ‚îÄ db.js              # MongoDB connection
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îÇ       ‚îî‚îÄ‚îÄ Message.js     # Message schema
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ index.html         # Redirect
‚îÇ   ‚îú‚îÄ‚îÄ login.html         # ‚Üê LOGIN PAGE HERE
‚îÇ   ‚îú‚îÄ‚îÄ login.css          # Login styles
‚îÇ   ‚îú‚îÄ‚îÄ login.js           # Login logic
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html     # Dashboard
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.css      # Dashboard styles
‚îÇ   ‚îî‚îÄ‚îÄ dashboard.js       # Dashboard logic
‚îú‚îÄ‚îÄ .env.example           # Template
‚îú‚îÄ‚îÄ package.json           # Dependencies
‚îî‚îÄ‚îÄ README.md             # This file
```

**Login page location:** `web/login.html`

---

## üöÄ Quick Setup

### 1. Install Prerequisites

**Node.js** (v16+): https://nodejs.org/

**MongoDB:**
- Mac: `brew install mongodb-community`
- Ubuntu: `sudo apt install mongodb`
- Windows: https://www.mongodb.com/try/download/community

### 2. Start MongoDB

```bash
# Mac
brew services start mongodb-community

# Linux
sudo systemctl start mongod

# Or manually
mongod --dbpath ~/data/db
```

### 3. Setup Project

```bash
cd sms-container-server
npm install
cp .env.example .env
```

### 4. Configure .env

Edit `.env`:
```env
MONGO_URI=mongodb://localhost:27017/sms_db
PORT=4000
ADMIN_EMAIL=your-email@example.com
ADMIN_PASSWORD=YourPassword123
```

### 5. Start Server

```bash
npm start
```

### 6. Access

Open: `http://localhost:4000`

Login page: `http://localhost:4000/login.html`

---

## üîê Authentication

### How It Works

1. Open `http://localhost:4000`
2. Redirects to `login.html` (the login page)
3. Enter email & password from `.env`
4. Server checks credentials
5. Success ‚Üí Dashboard
6. Fail ‚Üí Error message

### Credentials Location

All credentials are in `.env` file:
```env
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=SecurePassword123
```

---

## üì° API Endpoints

### POST /login
```json
Request:
{
  "email": "admin@example.com",
  "password": "SecurePassword123"
}

Success (200):
{
  "ok": true,
  "message": "Login successful",
  "user": { "email": "admin@example.com" }
}

Error (401):
{
  "ok": false,
  "error": "invalid_credentials",
  "message": "Invalid email or password"
}
```

### POST /upload-messages
```json
Request:
{
  "messages": [
    {
      "phone": "+1234567890",
      "name": "John Doe",
      "body": "Hello!",
      "direction": "received",
      "timestamp": "2025-01-30T12:00:00Z"
    }
  ]
}

Response (200):
{
  "ok": true,
  "message": "Messages uploaded successfully",
  "count": 1
}
```

### GET /threads
```json
Response:
[
  {
    "phone": "+1234567890",
    "name": "John Doe",
    "last": "2025-01-30T12:00:00Z",
    "lastBody": "Hello!"
  }
]
```

### GET /messages/:phone
```json
Response:
[
  {
    "phone": "+1234567890",
    "name": "John Doe",
    "body": "Hello!",
    "direction": "received",
    "timestamp": "2025-01-30T12:00:00Z"
  }
]
```

### GET /health
```json
Response:
{
  "ok": true,
  "status": "healthy",
  "timestamp": "2025-01-30T12:34:56.789Z"
}
```

---

## üß™ Testing

### Test Login
```bash
curl -X POST http://localhost:4000/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"SecurePassword123"}'
```

### Upload Message
```bash
curl -X POST http://localhost:4000/upload-messages \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [{
      "phone": "+1234567890",
      "name": "Test",
      "body": "Test message",
      "direction": "received",
      "timestamp": "2025-01-30T12:00:00Z"
    }]
  }'
```

### Get Threads
```bash
curl http://localhost:4000/threads
```

---

## üì± Flutter Integration

```dart
Future<bool> login(String email, String password) async {
  final response = await http.post(
    Uri.parse('$baseUrl/login'),
    headers: {'Content-Type': 'application/json'},
    body: json.encode({
      'email': email,
      'password': password,
    }),
  );
  
  if (response.statusCode == 200) {
    final data = json.decode(response.body);
    return data['ok'] == true;
  }
  return false;
}
```

---

## üö¢ Deployment (Without Docker)

### Render / Railway / Heroku

1. Create account
2. Create web service
3. Connect GitHub
4. Set build: `npm install`
5. Set start: `npm start`
6. Add environment variables:
   - `MONGO_URI` (use MongoDB Atlas)
   - `PORT`
   - `ADMIN_EMAIL`
   - `ADMIN_PASSWORD`
7. Deploy

### MongoDB Atlas (Free)
1. Go to https://www.mongodb.com/cloud/atlas
2. Create free cluster
3. Get connection string
4. Use as `MONGO_URI`

---

## üêõ Troubleshooting

**Can't find login page?**
‚Üí It's at `web/login.html`
‚Üí Visit `http://localhost:4000/login.html`

**Can't login?**
‚Üí Check `.env` file has correct credentials
‚Üí Password is case-sensitive
‚Üí Email is case-insensitive

**MongoDB error?**
‚Üí Check MongoDB is running
‚Üí Test with: `mongo` in terminal
‚Üí Check `MONGO_URI` in `.env`

**Port in use?**
‚Üí Change `PORT` in `.env` to 5000

---

## üìÇ Where Are the Files?

**Login Page:**
- `web/login.html` ‚Üê Main login page
- `web/login.css` ‚Üê Styles
- `web/login.js` ‚Üê Logic

**Dashboard:**
- `web/dashboard.html`
- `web/dashboard.css`
- `web/dashboard.js`

**Server:**
- `server/routes.js` ‚Üê API with email/password auth
- `server/index.js` ‚Üê Main server
- `server/db.js` ‚Üê MongoDB

---

## üé® Web Interface

### Login Page
- Professional design
- Email & password fields
- Validation
- Error messages
- Gradient background

### Dashboard
- Header with user email
- Threads list
- Message conversations
- Refresh button
- Sign out
- Responsive

---

## üîí Security

**Current:**
‚úÖ Environment variables  
‚úÖ Email validation  
‚úÖ Request validation  
‚úÖ Session management  
‚úÖ XSS protection  

**For Production:**
‚ö†Ô∏è Add HTTPS  
‚ö†Ô∏è Add bcrypt password hashing  
‚ö†Ô∏è Add rate limiting  

---

## üìù Environment Variables

```env
# Required
MONGO_URI=mongodb://localhost:27017/sms_db
PORT=4000
ADMIN_EMAIL=your-email@example.com
ADMIN_PASSWORD=YourPassword123
```

---

## ‚ùì Common Questions

**Q: Where is the login page?**  
A: `web/login.html`

**Q: Do I need Docker?**  
A: No! Just Node.js + MongoDB

**Q: How do I change the password?**  
A: Edit `.env` file, restart server

**Q: Can I add more users?**  
A: Currently single user only. Extend `routes.js` for multi-user

**Q: Is this production-ready?**  
A: Add bcrypt hashing first for production

---

**Version:** 2.0  
**No Docker Required**  
**Simple Node.js + MongoDB Setup**
</file>

<file path="server/db.js">
const mongoose = require('mongoose');

async function connect(uri) {
  try {
    await mongoose.connect(uri, { useNewUrlParser: true, useUnifiedTopology: true });
    console.log('MongoDB connected');
  } catch (err) {
    console.error('MongoDB connection error', err);
    process.exit(1);
  }
}

module.exports = { connect };
</file>

<file path="server/index.js">
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const routes = require('./routes');
const db = require('./db');

const app = express();
app.use(cors());
app.use(bodyParser.json());

// Logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url} - ${req.ip}`);
  next();
});

// Serve web UI
app.use('/', express.static(__dirname + '/../web'));

app.use('/', routes);

const PORT = process.env.PORT || 4000;

async function start() {
  const mongoUri = process.env.MONGO_URI;
  if (!mongoUri) {
    console.error('MONGO_URI not set in environment');
    process.exit(1);
  }

  await db.connect(mongoUri);

  app.listen(PORT, () => {
    console.log(`Server listening on ${PORT}`);
  });

  // KEEP-ALIVE: internal periodic ping to /health every 14 seconds.
  // Purpose: Prevent some hosting providers from putting the process to sleep by making
  // internal self-requests. This is done inside the process and does not rely on external services.
  setInterval(async () => {
    try {
      // Use Node's global fetch (available in Node 18+). If unavailable, this will throw.
      await fetch(`http://localhost:${PORT}/health`);
    } catch (err) {
      // ignore errors - this is best-effort
    }
  }, 14000);
}

start();
</file>

<file path="server/models/Message.js">
const mongoose = require('mongoose');

const MessageSchema = new mongoose.Schema({
  phone: { type: String, required: true },
  name: { type: String, default: null },
  body: { type: String, required: true },
  direction: { type: String, enum: ['sent','received'], required: true },
  timestamp: { type: Date, required: true },
});

module.exports = mongoose.model('Message', MessageSchema);
</file>

<file path="server/routes.js">
const express = require("express");
const router = express.Router();
const Message = require("./models/Message");

// Redirect root to login page
router.get("/", (req, res) => {
  res.redirect("/login.html");
});

// POST /login - Authenticate user with email and password from environment variables
router.post("/login", (req, res) => {
  try {
    const { email, password } = req.body;

    // Get credentials from environment variables
    const ADMIN_EMAIL = process.env.ADMIN_EMAIL;
    const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;

    // Check if environment variables are set
    if (!ADMIN_EMAIL || !ADMIN_PASSWORD) {
      console.error(
        "ADMIN_EMAIL or ADMIN_PASSWORD not set in environment variables",
      );
      return res.status(500).json({
        ok: false,
        error: "server_configuration_error",
        message: "Server is not configured properly",
      });
    }

    // Validation
    if (!email || !password) {
      return res.status(400).json({
        ok: false,
        error: "credentials_required",
        message: "Email and password are required",
      });
    }

    // Check credentials
    if (
      email.toLowerCase() === ADMIN_EMAIL.toLowerCase() &&
      password === ADMIN_PASSWORD
    ) {
      return res.status(200).json({
        ok: true,
        message: "Login successful",
        user: {
          email: ADMIN_EMAIL,
        },
      });
    } else {
      return res.status(401).json({
        ok: false,
        error: "invalid_credentials",
        message: "Invalid email or password",
      });
    }
  } catch (err) {
    console.error("Login error:", err);
    return res.status(500).json({
      ok: false,
      error: "server_error",
      message: "Internal server error",
    });
  }
});

// POST /upload-messages - accepts array of messages and stores them
router.post("/upload-messages", async (req, res) => {
  try {
    const { messages } = req.body;

    // Validation
    if (!messages) {
      return res.status(400).json({
        ok: false,
        error: "messages_required",
        message: "Messages array is required",
      });
    }

    if (!Array.isArray(messages)) {
      return res.status(400).json({
        ok: false,
        error: "invalid_format",
        message: "Messages must be an array",
      });
    }

    if (messages.length === 0) {
      return res.status(400).json({
        ok: false,
        error: "empty_array",
        message: "Messages array cannot be empty",
      });
    }

    // Validate message structure
    for (let i = 0; i < messages.length; i++) {
      const msg = messages[i];
      if (!msg.phone || !msg.body || !msg.direction || !msg.timestamp) {
        return res.status(400).json({
          ok: false,
          error: "invalid_message_structure",
          message: `Message at index ${i} is missing required fields (phone, body, direction, timestamp)`,
        });
      }

      if (!["sent", "received"].includes(msg.direction)) {
        return res.status(400).json({
          ok: false,
          error: "invalid_direction",
          message: `Message at index ${i} has invalid direction. Must be 'sent' or 'received'`,
        });
      }
    }

    // Transform and insert messages
    const docs = messages.map((m) => ({
      phone: m.phone,
      name: m.name || null,
      body: m.body,
      direction: m.direction,
      timestamp: new Date(m.timestamp),
    }));

    const result = await Message.insertMany(docs, { ordered: false });

    return res.status(200).json({
      ok: true,
      message: "Messages uploaded successfully",
      count: result.length,
    });
  } catch (err) {
    // Handle duplicate key errors gracefully
    if (err.code === 11000) {
      return res.status(200).json({
        ok: true,
        message: "Messages processed (some duplicates skipped)",
        warning: "Some messages were already in the database",
      });
    }

    console.error("Upload error:", err);
    return res.status(500).json({
      ok: false,
      error: "server_error",
      message: "Failed to upload messages",
    });
  }
});

// GET /threads - return unique phone numbers with latest timestamp
router.get("/threads", async (req, res) => {
  try {
    const results = await Message.aggregate([
      { $sort: { timestamp: -1 } },
      {
        $group: {
          _id: "$phone",
          name: { $first: "$name" },
          last: { $first: "$timestamp" },
          lastBody: { $first: "$body" },
        },
      },
      {
        $project: {
          phone: "$_id",
          name: 1,
          last: 1,
          lastBody: 1,
          _id: 0,
        },
      },
      { $sort: { last: -1 } },
    ]);

    return res.status(200).json(results);
  } catch (err) {
    console.error("Get threads error:", err);
    return res.status(500).json({
      ok: false,
      error: "server_error",
      message: "Failed to retrieve threads",
    });
  }
});

// GET /messages/:phone - return messages for phone sorted oldest->newest
router.get("/messages/:phone", async (req, res) => {
  try {
    const phone = req.params.phone;

    if (!phone) {
      return res.status(400).json({
        ok: false,
        error: "phone_required",
        message: "Phone number is required",
      });
    }

    const messages = await Message.find({ phone })
      .sort({ timestamp: 1 })
      .lean();

    return res.status(200).json(messages);
  } catch (err) {
    console.error("Get messages error:", err);
    return res.status(500).json({
      ok: false,
      error: "server_error",
      message: "Failed to retrieve messages",
    });
  }
});

// GET /health - Health check endpoint
router.get("/health", (req, res) => {
  res.status(200).json({
    ok: true,
    status: "healthy",
    timestamp: new Date().toISOString(),
  });
});

module.exports = router;
</file>

<file path="web/dashboard.css">
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    background: #f5f6fa;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background: #2c3e50;
    color: #ffffff;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    position: sticky;
    top: 0;
    z-index: 100;
}

.header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 16px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.header-title {
    font-size: 20px;
    font-weight: 600;
    letter-spacing: -0.5px;
}

.header-actions {
    display: flex;
    gap: 12px;
    align-items: center;
}

.btn-icon {
    background: transparent;
    border: none;
    color: #ffffff;
    cursor: pointer;
    padding: 8px;
    border-radius: 6px;
    transition: background 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-icon:hover {
    background: rgba(255, 255, 255, 0.1);
}

.btn-secondary {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #ffffff;
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
}

.btn-secondary:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.5);
}

/* Main Content */
.main-content {
    flex: 1;
    max-width: 1200px;
    width: 100%;
    margin: 0 auto;
    padding: 24px;
}

.view {
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    min-height: calc(100vh - 120px);
}

.hidden {
    display: none !important;
}

/* Content Header */
.content-header {
    padding: 24px;
    border-bottom: 1px solid #e8e9ed;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.content-header h2 {
    font-size: 22px;
    font-weight: 600;
    color: #2c3e50;
}

.count-badge {
    background: #ecf0f1;
    color: #7f8c8d;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
}

/* Threads Container */
.threads-container {
    padding: 0;
}

/* Loading State */
.loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 24px;
    color: #7f8c8d;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid #ecf0f1;
    border-top-color: #2c3e50;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 16px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.loading p {
    font-size: 14px;
}

/* Empty State */
.empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 24px;
    color: #95a5a6;
}

.empty-state svg {
    margin-bottom: 20px;
    opacity: 0.6;
}

.empty-state h3 {
    font-size: 18px;
    color: #7f8c8d;
    margin-bottom: 8px;
    font-weight: 500;
}

.empty-state p {
    font-size: 14px;
    color: #95a5a6;
}

/* Thread List */
.thread-list {
    list-style: none;
}

.thread-item {
    padding: 20px 24px;
    border-bottom: 1px solid #ecf0f1;
    cursor: pointer;
    transition: background 0.2s ease;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.thread-item:hover {
    background: #f8f9fa;
}

.thread-item:last-child {
    border-bottom: none;
}

.thread-main {
    flex: 1;
    min-width: 0;
}

.thread-contact {
    font-size: 16px;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 4px;
}

.thread-preview {
    font-size: 14px;
    color: #7f8c8d;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 500px;
}

.thread-meta {
    text-align: right;
    margin-left: 16px;
}

.thread-time {
    font-size: 12px;
    color: #95a5a6;
    white-space: nowrap;
}

/* Chat View */
.chat-header {
    padding: 20px 24px;
    border-bottom: 1px solid #e8e9ed;
    display: flex;
    align-items: center;
    gap: 16px;
}

.btn-back {
    background: transparent;
    border: 1px solid #e0e0e0;
    color: #2c3e50;
    padding: 8px 14px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
    font-family: inherit;
}

.btn-back:hover {
    background: #f8f9fa;
    border-color: #d0d0d0;
}

.chat-info {
    flex: 1;
}

.chat-name {
    font-size: 18px;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 2px;
}

.chat-phone {
    font-size: 13px;
    color: #7f8c8d;
}

/* Messages Container */
.messages-container {
    padding: 24px;
    max-height: calc(100vh - 220px);
    overflow-y: auto;
}

.messages-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Message Bubble */
.message {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 12px;
    word-wrap: break-word;
    display: flex;
    flex-direction: column;
}

.message.sent {
    align-self: flex-end;
    background: #2c3e50;
    color: #ffffff;
    border-bottom-right-radius: 4px;
}

.message.received {
    align-self: flex-start;
    background: #ecf0f1;
    color: #2c3e50;
    border-bottom-left-radius: 4px;
}

.message-body {
    font-size: 15px;
    line-height: 1.4;
    margin-bottom: 6px;
}

.message-time {
    font-size: 11px;
    opacity: 0.7;
    text-align: right;
}

.message.received .message-time {
    text-align: left;
}

/* Scrollbar Styling */
.messages-container::-webkit-scrollbar {
    width: 8px;
}

.messages-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.messages-container::-webkit-scrollbar-thumb {
    background: #bdc3c7;
    border-radius: 4px;
}

.messages-container::-webkit-scrollbar-thumb:hover {
    background: #95a5a6;
}

/* Responsive Design */
@media (max-width: 768px) {
    .header-content {
        padding: 12px 16px;
    }
    
    .header-title {
        font-size: 18px;
    }
    
    .main-content {
        padding: 16px;
    }
    
    .content-header {
        padding: 16px;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .thread-item {
        padding: 16px;
    }
    
    .thread-preview {
        max-width: 250px;
    }
    
    .message {
        max-width: 85%;
    }
    
    .chat-header {
        padding: 16px;
    }
    
    .messages-container {
        padding: 16px;
        max-height: calc(100vh - 200px);
    }
}
</file>

<file path="web/dashboard.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMS Container - Dashboard</title>
  <link rel="stylesheet" href="/dashboard.css">
</head>

<body>
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <h1 class="header-title">SMS Container</h1>
      <div class="header-actions">
        <span id="userEmail" class="user-email"></span>
        <button id="refreshBtn" class="btn-icon" title="Refresh">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" />
          </svg>
        </button>
        <button id="logoutBtn" class="btn-secondary">Sign Out</button>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="main-content">
    <!-- Threads List View -->
    <div id="threadsView" class="view">
      <div class="content-header">
        <h2>Message Threads</h2>
        <span id="threadCount" class="count-badge">0 conversations</span>
      </div>

      <div id="threadsContainer" class="threads-container">
        <div id="loadingThreads" class="loading">
          <div class="spinner"></div>
          <p>Loading conversations...</p>
        </div>
        <div id="noThreads" class="empty-state hidden">
          <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
          </svg>
          <h3>No conversations yet</h3>
          <p>Messages will appear here when available</p>
        </div>
        <ul id="threadList" class="thread-list hidden"></ul>
      </div>
    </div>

    <!-- Chat View -->
    <div id="chatView" class="view hidden">
      <div class="chat-header">
        <button id="backBtn" class="btn-back">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 12H5M12 19l-7-7 7-7" />
          </svg>
          Back
        </button>
        <div class="chat-info">
          <h2 id="chatTitle" class="chat-name">Contact</h2>
          <p id="chatPhone" class="chat-phone"></p>
        </div>
      </div>

      <div id="messagesContainer" class="messages-container">
        <div id="messagesList" class="messages-list"></div>
      </div>
    </div>
  </main>

  <script src="/dashboard.js"></script>
</body>

</html>
</file>

<file path="web/dashboard.js">
// Check authentication on load
if (!sessionStorage.getItem("authenticated")) {
  window.location.href = "/login.html";
}

// Display user email
const userEmailDisplay = document.getElementById("userEmail");
const userEmail = sessionStorage.getItem("userEmail");
if (userEmail) {
  userEmailDisplay.textContent = userEmail;
}

// API Helper Functions
async function getJson(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error("Request failed");
  return res.json();
}

// DOM Elements
const threadsView = document.getElementById("threadsView");
const chatView = document.getElementById("chatView");
const threadList = document.getElementById("threadList");
const loadingThreads = document.getElementById("loadingThreads");
const noThreads = document.getElementById("noThreads");
const threadCount = document.getElementById("threadCount");
const chatTitle = document.getElementById("chatTitle");
const chatPhone = document.getElementById("chatPhone");
const messagesList = document.getElementById("messagesList");
const backBtn = document.getElementById("backBtn");
const logoutBtn = document.getElementById("logoutBtn");
const refreshBtn = document.getElementById("refreshBtn");

let currentPhone = null;
let autoRefreshInterval = null;

// Logout Handler
logoutBtn.addEventListener("click", () => {
  sessionStorage.removeItem("authenticated");
  sessionStorage.removeItem("userEmail");
  window.location.href = "/login.html";
});

// Refresh Handler
refreshBtn.addEventListener("click", async () => {
  refreshBtn.style.transform = "rotate(360deg)";
  refreshBtn.style.transition = "transform 0.5s ease";
  await loadThreads();
  setTimeout(() => {
    refreshBtn.style.transform = "";
  }, 500);
});

// Back Button Handler
backBtn.addEventListener("click", () => {
  chatView.classList.add("hidden");
  threadsView.classList.remove("hidden");
  currentPhone = null;
  // Resume auto-refresh when back to threads view
  startAutoRefresh();
});

// Load Threads Function
async function loadThreads() {
  try {
    const data = await getJson("/threads");

    // Hide loading, show appropriate content
    loadingThreads.classList.add("hidden");

    if (data.length === 0) {
      noThreads.classList.remove("hidden");
      threadList.classList.add("hidden");
      threadCount.textContent = "0 conversations";
    } else {
      noThreads.classList.add("hidden");
      threadList.classList.remove("hidden");
      threadCount.textContent = `${data.length} conversation${data.length !== 1 ? "s" : ""}`;
      renderThreads(data);
    }
  } catch (error) {
    console.error("Failed to load threads:", error);
    loadingThreads.innerHTML = `
            <div class="loading">
                <p style="color: #e74c3c;">Failed to load conversations</p>
            </div>
        `;
  }
}

// Render Threads
function renderThreads(threads) {
  threadList.innerHTML = "";

  threads.forEach((thread) => {
    const li = document.createElement("li");
    li.className = "thread-item";

    const displayName = thread.name || thread.phone;
    const preview = thread.lastBody || "No messages";
    const timestamp = formatTimestamp(thread.last);

    li.innerHTML = `
            <div class="thread-main">
                <div class="thread-contact">${escapeHtml(displayName)}</div>
                <div class="thread-preview">${escapeHtml(preview)}</div>
            </div>
            <div class="thread-meta">
                <div class="thread-time">${timestamp}</div>
            </div>
        `;

    li.addEventListener("click", () => openThread(thread.phone, thread.name));
    threadList.appendChild(li);
  });
}

// Open Thread
async function openThread(phone, name) {
  currentPhone = phone;

  // Stop auto-refresh when viewing a thread
  stopAutoRefresh();

  threadsView.classList.add("hidden");
  chatView.classList.remove("hidden");

  chatTitle.textContent = name || phone;
  chatPhone.textContent = phone;

  messagesList.innerHTML =
    '<div class="loading"><div class="spinner"></div><p>Loading messages...</p></div>';

  try {
    const messages = await getJson("/messages/" + encodeURIComponent(phone));
    renderMessages(messages);
  } catch (error) {
    console.error("Failed to load messages:", error);
    messagesList.innerHTML =
      '<div class="loading"><p style="color: #e74c3c;">Failed to load messages</p></div>';
  }
}

// Render Messages
function renderMessages(messages) {
  messagesList.innerHTML = "";

  if (messages.length === 0) {
    messagesList.innerHTML = `
            <div class="empty-state">
                <p>No messages in this conversation</p>
            </div>
        `;
    return;
  }

  messages.forEach((message) => {
    const div = document.createElement("div");
    div.className = `message ${message.direction}`;

    div.innerHTML = `
            <div class="message-body">${escapeHtml(message.body)}</div>
            <div class="message-time">${formatTimestamp(message.timestamp)}</div>
        `;

    messagesList.appendChild(div);
  });

  // Scroll to bottom
  messagesList.scrollTop = messagesList.scrollHeight;
}

// Format Timestamp
function formatTimestamp(timestamp) {
  const date = new Date(timestamp);
  const now = new Date();
  const diff = now - date;

  // Less than 1 minute
  if (diff < 60000) {
    return "Just now";
  }

  // Less than 1 hour
  if (diff < 3600000) {
    const minutes = Math.floor(diff / 60000);
    return `${minutes} min${minutes !== 1 ? "s" : ""} ago`;
  }

  // Today
  if (date.toDateString() === now.toDateString()) {
    return date.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    });
  }

  // Yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (date.toDateString() === yesterday.toDateString()) {
    return "Yesterday";
  }

  // This year
  if (date.getFullYear() === now.getFullYear()) {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  }

  // Other years
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

// Auto-refresh threads every 10 seconds
function startAutoRefresh() {
  stopAutoRefresh(); // Clear any existing interval
  autoRefreshInterval = setInterval(() => {
    if (!chatView.classList.contains("hidden")) return; // Don't refresh if in chat view
    loadThreads();
  }, 10000);
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

// Initial Load
loadThreads();
startAutoRefresh();

// Cleanup on page unload
window.addEventListener("beforeunload", () => {
  stopAutoRefresh();
});
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="refresh" content="0;url=/login.html">
  <title>Redirecting...</title>
</head>

<body>
  <script>
    window.location.href = '/login.html';
  </script>
</body>

</html>
</file>

<file path="web/login.css">
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.login-container {
    width: 100%;
    max-width: 420px;
}

.login-card {
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    overflow: hidden;
}

.login-header {
    background: #2c3e50;
    color: #ffffff;
    padding: 40px 30px;
    text-align: center;
}

.login-header h1 {
    font-size: 28px;
    font-weight: 600;
    margin-bottom: 8px;
    letter-spacing: -0.5px;
}

.subtitle {
    font-size: 14px;
    color: #bdc3c7;
    font-weight: 400;
}

.login-form {
    padding: 40px 30px;
}

.form-group {
    margin-bottom: 24px;
}

.form-group label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: #2c3e50;
    margin-bottom: 8px;
}

.form-group input {
    width: 100%;
    padding: 14px 16px;
    font-size: 15px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    transition: all 0.3s ease;
    font-family: inherit;
    background: #f8f9fa;
}

.form-group input:focus {
    outline: none;
    border-color: #667eea;
    background: #ffffff;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.error-message {
    color: #e74c3c;
    font-size: 13px;
    margin-bottom: 20px;
    min-height: 18px;
    font-weight: 500;
}

.btn-login {
    width: 100%;
    padding: 14px;
    background: #2c3e50;
    color: #ffffff;
    border: none;
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
}

.btn-login:hover {
    background: #34495e;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
}

.btn-login:active {
    transform: translateY(0);
}

.login-footer {
    background: #f8f9fa;
    padding: 20px 30px;
    text-align: center;
    border-top: 1px solid #e0e0e0;
}

.login-footer p {
    font-size: 12px;
    color: #7f8c8d;
}

/* Responsive Design */
@media (max-width: 480px) {
    .login-header {
        padding: 30px 20px;
    }
    
    .login-header h1 {
        font-size: 24px;
    }
    
    .login-form {
        padding: 30px 20px;
    }
}
</file>

<file path="web/login.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMS Container - Login</title>
  <link rel="stylesheet" href="/login.css">
</head>

<body>
  <div class="login-container">
    <div class="login-card">
      <div class="login-header">
        <h1>SMS Container</h1>
        <p class="subtitle">Secure Message Management System</p>
      </div>

      <form id="loginForm" class="login-form">
        <div class="form-group">
          <label for="email">Email Address</label>
          <input type="email" id="email" name="email" placeholder="Enter your email" autocomplete="email" required />
        </div>

        <div class="form-group">
          <label for="password">Password</label>
          <input type="password" id="password" name="password" placeholder="Enter your password"
            autocomplete="current-password" required />
        </div>

        <div id="errorMsg" class="error-message"></div>

        <button type="submit" id="btnLogin" class="btn-login">
          Sign In
        </button>
      </form>

      <div class="login-footer">
        <p>&copy; 2025 SMS Container. All rights reserved.</p>
      </div>
    </div>
  </div>

  <script src="/login.js"></script>
</body>

</html>
</file>

<file path="web/login.js">
async function post(path, body) {
  const res = await fetch(path, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  return res;
}

const loginForm = document.getElementById("loginForm");
const emailInput = document.getElementById("email");
const passwordInput = document.getElementById("password");
const errorMsg = document.getElementById("errorMsg");
const btnLogin = document.getElementById("btnLogin");

loginForm.addEventListener("submit", async (e) => {
  e.preventDefault();

  const email = emailInput.value.trim();
  const password = passwordInput.value.trim();

  // Validation
  if (!email) {
    errorMsg.textContent = "Please enter your email address";
    emailInput.focus();
    return;
  }

  if (!password) {
    errorMsg.textContent = "Please enter your password";
    passwordInput.focus();
    return;
  }

  // Email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    errorMsg.textContent = "Please enter a valid email address";
    emailInput.focus();
    return;
  }

  // Disable button during login
  btnLogin.disabled = true;
  btnLogin.textContent = "Signing in...";
  errorMsg.textContent = "";

  try {
    const res = await post("/login", { email, password });
    const data = await res.json();

    if (res.status === 200 && data.ok) {
      // Store authentication state
      sessionStorage.setItem("authenticated", "true");
      sessionStorage.setItem("userEmail", data.user.email);

      // Show success message briefly
      btnLogin.textContent = "Success!";

      // Redirect to dashboard
      setTimeout(() => {
        window.location.href = "/dashboard.html";
      }, 500);
    } else {
      // Handle error response
      errorMsg.textContent =
        data.message || "Invalid email or password. Please try again.";
      btnLogin.disabled = false;
      btnLogin.textContent = "Sign In";
      passwordInput.value = "";
      passwordInput.focus();
    }
  } catch (error) {
    console.error("Login error:", error);
    errorMsg.textContent =
      "Connection error. Please check your internet and try again.";
    btnLogin.disabled = false;
    btnLogin.textContent = "Sign In";
  }
});

// Auto-focus email input on load
window.addEventListener("load", () => {
  emailInput.focus();
});

// Clear error message when user starts typing
emailInput.addEventListener("input", () => {
  if (errorMsg.textContent) {
    errorMsg.textContent = "";
  }
});

passwordInput.addEventListener("input", () => {
  if (errorMsg.textContent) {
    errorMsg.textContent = "";
  }
});
</file>

</files>
